## Условия тестового задания

Адрес для запросов и ws-соединения http://testapi.marit.expert:3003. Пользователь для аутентификации:логин - `simsim`, пароль - `12345`. Выполненное задание залить на GitHub. В репозитории должны быть как исходники так и собранный проект. Ссылку на репозиторий отправить vadim.lilianov@marit.expert. По всем вопросам обращаться vadim.lilianov@marit.expert

## Минимально обязательный стэк технологий
 - React
 - React router
 - Redux
 - Redux Thunk middleware
 - Socket.io
 - HTTP
 - Bootstrap/Materialize
 - webpack

## Задача
Создать SPA с двумя страницами - логин, отображение данных. К вёрстке два требования: 
1) адаптивность для разных разрешений монитора(для двух будет достаточно). 
2) страница отображения данных имеет вид 4 колонок в которых отображаются персонажи соответсвующей расы. Остальная вёрстка и внешний вид приложения - на Ваше усмотрение. Способ изображения персонажа в колонке на Ваше усмотрение(прямоугольник, пиктограмма, картинка и тд).

## Необходимые функции которое должно выполнять приложение

```
1. Аутентификация
```
1. Аутентификация пользователя. Аутентификация пользователя производится отправкой POST-запроса на путь "/auth". Тело запроса должно содержать поля "login" и "password". Формат кодировки тела "application/x-www-form-urlencoded". Формат ответов от сервера всегда "json". Варианты ответа от сервера:
 - "{success:true}" - аутентификация успешна. Направить пользователя на страницу с данными
 - "{success:false, err:"wrong password"}" - неверный пароль. Вывести соответсвующее уведоммление пользователю.
 - "{success:false, err:`no such user`}" - пользователь не существует. Вывести соответсвующее уведоммление пользователю.
   Проверка сессии. Проверка сессии пользователя производится отправкой GET-запроса на путь "/check". Формат ответов от сервера всегда "json". Варианты ответа от сервера:
 - "{success:true}" - проверка сессии успешна. Направить пользователя на страницу с данными
 - "{success:false}" - проверка сессии неуспешна. Направить пользователя на страницу аутентификации
   Завершение сессии. Проверка сессии пользователя производится отправкой GET-запроса на путь "/logout". Формат ответов от сервера всегда "json". Варианты ответа от сервера:
 - "{success:true}" - завершение сессии прошло успешно. Направить пользователя на страницу аутентификации
 - "{success:false}" - завершение сессии прошло неуспешно. Вывести соответсвующее уведоммление пользователю.

```
2. Вёрстка
```

1. Страница логина. *На Ваше усмотрение*
2. Страница с данными. Страница с данными должна содержать минимум 4 колонки где будут отображаться персонажи каждой расы. Есть 4 расы: Hobbit, Human, Dworf, Elf. На каждой колонке должна быть кнопка "Добавить". На каждом элементе в колонке должны быть кнопки "Изменить имя" и "Удалить". Вид кнопок на ваше усмотрение(текст или пиктограмма или картинка)

```
3. CRUD
```

Все операции с данными выполняются через websocket. Websocket-соединение устанавливается только с аутентифицированными пользователями. Если неаутентифицированный пользователь попробует установить webscoket-соединение, то серевер сбросит эту попытку. За всю websocket-сессию клиент должен запрашивать данные один раз сразу после подключении. Далее список данных должен изменяться только от входящих сообщений. Формат общения через websocket "{cmd:"какаято комманда", data:{какие-то данные}}". Ответ от сервера может быть двумя способами: вернуть данные в callback или вернуть данные сообщением. В случае работы данными в callback возвращается статус операции, а изменённый/добавленный элемент вовзращается сообщением. В случае получения данных - данные возвращаются в callback.

1. Получение списка данных. Список данных запрашивается отправкой сообщения "{cmd:"get_list"}" на сервер. Данные вернутся в callback. На клиенте получение списка будет иметь примерно следующий вид:
```js
socket.send({cmd:"get_list"}, function(res){
//В res вернётся список данных для дальнейшей обработки
})
```
Данные имеют примерно следующий вид:[ { id:1, name:"Frodo", race:"Hobbit" }, { id:2, name:"Aragorn", race:"Human" }, { id:3, name:"Gimli", race:"Dworf" }, { id:4, name:"Legolas", race:"Elf" } ]
Каждый элемент списка необходимо отобразить в соответвующей колонке в зависимости от значения поля "race"

2. Добавить элемент в список. Добавление элемента в список выполняется отправкой комманды на сервер "{cmd:"add_in_list", data:{name:"NAME", race:"RACE"}}". Значение поля "name" вводится пользователем. Значение поля "race" должно быть автоматически заполнено в зависимти от того в колонку какой расы добавляют перонажа. В ответ в callback вернется "{success:true}", если добавление прошло успешно. Добавленный элемент вернется сообщением!!!(не в сallback) от сервера следующего вида "{cmd:"new_element_in_list", data:{id:$Integer$, name:$String$, race:$String$}}". Добавленный элемент необходимо разместить в соответсвубщей колонке по расе.

3. Редактировать элемент в списке. Редактирование поля "name" элемента в списке выполняется отправкой комманды на сервер "{cmd:"edit_in_list", data:{id:$Integer$,name:$String$}}". Значение поля "name" вводится пользователем. То есть на элементе должна быть кнопка, например, "Изменить имя". Редактирование поля "race" элемента в списке выполняется отправкой комманды "{cmd:"change_race", data:{id:$Integer$,race:$String$}}". Измнение расы должно быть реализовано через перетаскивание элмента из одной колонки в другую. В ответ в callback вернется "{success:true}", если редактирование прошло успешно; {success:false, err:"No such element with id=$Integer$"} если редактрование прошло нуеспешно. Отредактированный элемент вернется сообщением!!!(не в сallback) от сервера следующего вида "{cmd:"edit_element_name_in_list", data:{id:$Integer$, name:$String$, race:$String$}}" если редактировали имя; "{cmd:"edit_element_name_in_list", data:{id:$Integer$, name:$String$, race:$String$}}" если редактировали расу. Отредактированный элемент необходимо разместить в соответсвубщей колонке по расе.

4. Удалить элемент из списка. Удаление элемента из списке выполняется отправкой комманды на сервер "{cmd:"remove_from_list", data:{id:$Integer$}}". В ответ в callback вернется "{success:true}", если редактирование прошло успешно; {success:false, err:"No such element with id=$Integer$"} если редактрование прошло нуеспешно. Удаленный элемент вернется сообщением!!!(не в сallback) от сервера следующего вида "{cmd:"remove_element_from_list", data:{id:$Integer$}}". Удаленный элемент необходимо удалить в соответсвующей колонке по расе.

```
4. Роутинг
```

Должно быть мимнимум две страницы - аутентификация(например "`/login`") и данные(например, "`/characters`"). На страницу данных имеют доступ только аутентифицированные пользователи. Неаутентифицированных пользоватлей редиректить на страницу логина.

```
5. Сборка проекта
```

Как сборщик желательно использовать `webpack`. Прелоадеры, плагины и тд на Ваше усмотрение. Структура собранного проекта
```js
index.html
app.js
/static
/js
/css
/images
```
